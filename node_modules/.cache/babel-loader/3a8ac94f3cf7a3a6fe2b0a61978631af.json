{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/recurrence.js)\r\n * Version: 20.2.5\r\n * Build date: Fri Jan 15 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nexports.getRecurrenceProcessor = getRecurrenceProcessor;\n\nvar _errors = _interopRequireDefault(require(\"../../core/errors\"));\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _array = require(\"../../core/utils/array\");\n\nvar _rrule = require(\"rrule\");\n\nvar _date = _interopRequireDefault(require(\"../../core/utils/date\"));\n\nvar _utilsTimeZone = _interopRequireDefault(require(\"./utils.timeZone.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) {\n    return;\n  }\n\n  if (\"string\" === typeof o) {\n    return _arrayLikeToArray(o, minLen);\n  }\n\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n\n  if (\"Object\" === n && o.constructor) {\n    n = o.constructor.name;\n  }\n\n  if (\"Map\" === n || \"Set\" === n) {\n    return Array.from(o);\n  }\n\n  if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {\n    return _arrayLikeToArray(o, minLen);\n  }\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (null == len || len > arr.length) {\n    len = arr.length;\n  }\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (\"undefined\" === typeof Symbol || !(Symbol.iterator in Object(arr))) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _e = void 0;\n\n  try {\n    for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) {\n        break;\n      }\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && null != _i.return) {\n        _i.return();\n      }\n    } finally {\n      if (_d) {\n        throw _e;\n      }\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) {\n    return arr;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nvar toMs = _date.default.dateToMilliseconds;\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"];\nvar freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"];\nvar days = {\n  SU: 0,\n  MO: 1,\n  TU: 2,\n  WE: 3,\n  TH: 4,\n  FR: 5,\n  SA: 6\n};\nvar loggedWarnings = [];\nvar recurrence = null;\n\nfunction getRecurrenceProcessor() {\n  if (!recurrence) {\n    recurrence = new RecurrenceProcessor();\n  }\n\n  return recurrence;\n}\n\nvar RecurrenceProcessor = function () {\n  function RecurrenceProcessor() {\n    _classCallCheck(this, RecurrenceProcessor);\n\n    this.rRule = null;\n    this.rRuleSet = null;\n    this.validator = new RecurrenceValidator();\n  }\n\n  _createClass(RecurrenceProcessor, [{\n    key: \"generateDates\",\n    value: function (options) {\n      var result = [];\n      var recurrenceRule = this.evalRecurrenceRule(options.rule);\n      var rule = recurrenceRule.rule;\n\n      if (!recurrenceRule.isValid || !rule.freq) {\n        return result;\n      }\n\n      var startDateUtc = _utilsTimeZone.default.createUTCDateWithLocalOffset(options.start);\n\n      var endDateUtc = _utilsTimeZone.default.createUTCDateWithLocalOffset(options.end);\n\n      var minDateUtc = _utilsTimeZone.default.createUTCDateWithLocalOffset(options.min);\n\n      var maxDateUtc = _utilsTimeZone.default.createUTCDateWithLocalOffset(options.max);\n\n      var duration = endDateUtc ? endDateUtc.getTime() - startDateUtc.getTime() : 0;\n\n      this._initializeRRule(options, startDateUtc);\n\n      var minTime = minDateUtc.getTime();\n\n      var leftBorder = this._getLeftBorder(options, minDateUtc, duration);\n\n      this.rRuleSet.between(leftBorder, maxDateUtc, true).forEach(function (date) {\n        var endAppointmentTime = date.getTime() + duration;\n\n        if (endAppointmentTime >= minTime) {\n          var correctDate = _utilsTimeZone.default.createDateFromUTCWithLocalOffset(date);\n\n          result.push(correctDate);\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"hasRecurrence\",\n    value: function (options) {\n      return !!this.generateDates(options).length;\n    }\n  }, {\n    key: \"evalRecurrenceRule\",\n    value: function (rule) {\n      var result = {\n        rule: {},\n        isValid: false\n      };\n\n      if (rule) {\n        result.rule = this._parseRecurrenceRule(rule);\n        result.isValid = this.validator.validateRRule(result.rule, rule);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"isValidRecurrenceRule\",\n    value: function (rule) {\n      return this.evalRecurrenceRule(rule).isValid;\n    }\n  }, {\n    key: \"daysFromByDayRule\",\n    value: function (rule) {\n      var result = [];\n\n      if (rule.byday) {\n        if (Array.isArray(rule.byday)) {\n          result = rule.byday;\n        } else {\n          result = rule.byday.split(\",\");\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getAsciiStringByDate\",\n    value: function (date) {\n      var currentOffset = this._getTimeZoneOffset() * toMs(\"minute\");\n      var offsetDate = new Date(date.getTime() + currentOffset);\n      return offsetDate.getFullYear() + (\"0\" + (offsetDate.getMonth() + 1)).slice(-2) + (\"0\" + offsetDate.getDate()).slice(-2) + \"T\" + (\"0\" + offsetDate.getHours()).slice(-2) + (\"0\" + offsetDate.getMinutes()).slice(-2) + (\"0\" + offsetDate.getSeconds()).slice(-2) + \"Z\";\n    }\n  }, {\n    key: \"getRecurrenceString\",\n    value: function (object) {\n      if (!object || !object.freq) {\n        return;\n      }\n\n      var result = \"\";\n\n      for (var field in object) {\n        var value = object[field];\n\n        if (\"interval\" === field && value < 2) {\n          continue;\n        }\n\n        if (\"until\" === field) {\n          value = this.getAsciiStringByDate(value);\n        }\n\n        result += field + \"=\" + value + \";\";\n      }\n\n      result = result.substring(0, result.length - 1);\n      return result.toUpperCase();\n    }\n  }, {\n    key: \"_parseExceptionToRawArray\",\n    value: function (value) {\n      return value.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/);\n    }\n  }, {\n    key: \"getDateByAsciiString\",\n    value: function (exceptionText) {\n      if (\"string\" !== typeof exceptionText) {\n        return exceptionText;\n      }\n\n      var result = this._parseExceptionToRawArray(exceptionText);\n\n      if (!result) {\n        return null;\n      }\n\n      var _this$_createDateTupl = this._createDateTuple(result),\n          _this$_createDateTupl2 = _slicedToArray(_this$_createDateTupl, 7),\n          year = _this$_createDateTupl2[0],\n          month = _this$_createDateTupl2[1],\n          date = _this$_createDateTupl2[2],\n          hours = _this$_createDateTupl2[3],\n          minutes = _this$_createDateTupl2[4],\n          seconds = _this$_createDateTupl2[5],\n          isUtc = _this$_createDateTupl2[6];\n\n      if (isUtc) {\n        return new Date(Date.UTC(year, month, date, hours, minutes, seconds));\n      }\n\n      return new Date(year, month, date, hours, minutes, seconds);\n    }\n  }, {\n    key: \"_dispose\",\n    value: function () {\n      if (this.rRuleSet) {\n        delete this.rRuleSet;\n        this.rRuleSet = null;\n      }\n\n      if (this.rRule) {\n        delete this.rRule;\n        this.rRule = null;\n      }\n    }\n  }, {\n    key: \"_getTimeZoneOffset\",\n    value: function () {\n      return new Date().getTimezoneOffset();\n    }\n  }, {\n    key: \"_initializeRRule\",\n    value: function (options, startDateUtc) {\n      var _this = this;\n\n      var ruleOptions = _rrule.RRule.parseString(options.rule);\n\n      var firstDayOfWeek = options.firstDayOfWeek;\n      ruleOptions.dtstart = startDateUtc;\n\n      if (!ruleOptions.wkst && firstDayOfWeek) {\n        var weekDayNumbers = [6, 0, 1, 2, 3, 4, 5];\n        ruleOptions.wkst = weekDayNumbers[firstDayOfWeek];\n      }\n\n      this._createRRule(ruleOptions);\n\n      if (options.exception) {\n        var exceptionStrings = options.exception;\n        var exceptionDates = exceptionStrings.split(\",\").map(function (rule) {\n          return _this.getDateByAsciiString(rule);\n        });\n        exceptionDates.forEach(function (date) {\n          if (options.getPostProcessedException) {\n            date = options.getPostProcessedException(date);\n          }\n\n          var utcDate = _utilsTimeZone.default.createUTCDateWithLocalOffset(date);\n\n          _this.rRuleSet.exdate(utcDate);\n        });\n      }\n    }\n  }, {\n    key: \"_createRRule\",\n    value: function (ruleOptions) {\n      this._dispose();\n\n      var rRuleSet = new _rrule.RRuleSet();\n      this.rRuleSet = rRuleSet;\n      this.rRule = new _rrule.RRule(ruleOptions);\n      this.rRuleSet.rrule(this.rRule);\n    }\n  }, {\n    key: \"_getLeftBorder\",\n    value: function (options, minDateUtc, appointmentDuration) {\n      if (options.end && !_utilsTimeZone.default.isSameAppointmentDates(options.start, options.end)) {\n        return new Date(minDateUtc.getTime() - appointmentDuration);\n      }\n\n      return minDateUtc;\n    }\n  }, {\n    key: \"_parseRecurrenceRule\",\n    value: function (recurrence) {\n      var ruleObject = {};\n      var ruleParts = recurrence.split(\";\");\n\n      for (var i = 0, len = ruleParts.length; i < len; i++) {\n        var rule = ruleParts[i].split(\"=\");\n        var ruleName = rule[0].toLowerCase();\n        var ruleValue = rule[1];\n        ruleObject[ruleName] = ruleValue;\n      }\n\n      var count = parseInt(ruleObject.count);\n\n      if (!isNaN(count)) {\n        ruleObject.count = count;\n      }\n\n      if (ruleObject.interval) {\n        var interval = parseInt(ruleObject.interval);\n\n        if (!isNaN(interval)) {\n          ruleObject.interval = interval;\n        }\n      } else {\n        ruleObject.interval = 1;\n      }\n\n      if (ruleObject.freq && ruleObject.until) {\n        ruleObject.until = this.getDateByAsciiString(ruleObject.until);\n      }\n\n      return ruleObject;\n    }\n  }, {\n    key: \"_createDateTuple\",\n    value: function (parseResult) {\n      var isUtc = void 0 !== parseResult[8];\n      parseResult.shift();\n\n      if (void 0 === parseResult[3]) {\n        parseResult.splice(3);\n      } else {\n        parseResult.splice(3, 1);\n        parseResult.splice(6);\n      }\n\n      parseResult[1]--;\n      parseResult.unshift(null);\n      return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc];\n    }\n  }]);\n\n  return RecurrenceProcessor;\n}();\n\nvar RecurrenceValidator = function () {\n  function RecurrenceValidator() {\n    _classCallCheck(this, RecurrenceValidator);\n  }\n\n  _createClass(RecurrenceValidator, [{\n    key: \"validateRRule\",\n    value: function (rule, recurrence) {\n      if (this._brokenRuleNameExists(rule) || (0, _array.inArray)(rule.freq, freqNames) === -1 || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {\n        this._logBrokenRule(recurrence);\n\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_wrongUntilRule\",\n    value: function (rule) {\n      var wrongUntil = false;\n      var until = rule.until;\n\n      if (void 0 !== until && !(until instanceof Date)) {\n        wrongUntil = true;\n      }\n\n      return wrongUntil;\n    }\n  }, {\n    key: \"_wrongCountRule\",\n    value: function (rule) {\n      var wrongCount = false;\n      var count = rule.count;\n\n      if (count && \"string\" === typeof count) {\n        wrongCount = true;\n      }\n\n      return wrongCount;\n    }\n  }, {\n    key: \"_wrongByMonthDayRule\",\n    value: function (rule) {\n      var wrongByMonthDay = false;\n      var byMonthDay = rule.bymonthday;\n\n      if (byMonthDay && isNaN(parseInt(byMonthDay))) {\n        wrongByMonthDay = true;\n      }\n\n      return wrongByMonthDay;\n    }\n  }, {\n    key: \"_wrongByMonth\",\n    value: function (rule) {\n      var wrongByMonth = false;\n      var byMonth = rule.bymonth;\n\n      if (byMonth && isNaN(parseInt(byMonth))) {\n        wrongByMonth = true;\n      }\n\n      return wrongByMonth;\n    }\n  }, {\n    key: \"_wrongIntervalRule\",\n    value: function (rule) {\n      var wrongInterval = false;\n      var interval = rule.interval;\n\n      if (interval && \"string\" === typeof interval) {\n        wrongInterval = true;\n      }\n\n      return wrongInterval;\n    }\n  }, {\n    key: \"_wrongDayOfWeek\",\n    value: function (rule) {\n      var byDay = rule.byday;\n      var daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);\n      var brokenDaysExist = false;\n\n      if (\"\" === byDay) {\n        brokenDaysExist = true;\n      }\n\n      (0, _iterator.each)(daysByRule, function (_, day) {\n        if (!Object.prototype.hasOwnProperty.call(days, day)) {\n          brokenDaysExist = true;\n          return false;\n        }\n      });\n      return brokenDaysExist;\n    }\n  }, {\n    key: \"_brokenRuleNameExists\",\n    value: function (rule) {\n      var brokenRuleExists = false;\n      (0, _iterator.each)(rule, function (ruleName) {\n        if ((0, _array.inArray)(ruleName, ruleNames) === -1) {\n          brokenRuleExists = true;\n          return false;\n        }\n      });\n      return brokenRuleExists;\n    }\n  }, {\n    key: \"_logBrokenRule\",\n    value: function (recurrence) {\n      if ((0, _array.inArray)(recurrence, loggedWarnings) === -1) {\n        _errors.default.log(\"W0006\", recurrence);\n\n        loggedWarnings.push(recurrence);\n      }\n    }\n  }]);\n\n  return RecurrenceValidator;\n}();","map":{"version":3,"sources":["F:/webfe/node_modules/devextreme/ui/scheduler/recurrence.js"],"names":["exports","getRecurrenceProcessor","_errors","_interopRequireDefault","require","_iterator","_array","_rrule","_date","_utilsTimeZone","obj","__esModule","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","Symbol","iterator","_arr","_n","_d","_e","_s","_i","next","done","push","value","err","return","isArray","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","toMs","default","dateToMilliseconds","ruleNames","freqNames","days","SU","MO","TU","WE","TH","FR","SA","loggedWarnings","recurrence","RecurrenceProcessor","rRule","rRuleSet","validator","RecurrenceValidator","options","result","recurrenceRule","evalRecurrenceRule","rule","isValid","freq","startDateUtc","createUTCDateWithLocalOffset","start","endDateUtc","end","minDateUtc","min","maxDateUtc","max","duration","getTime","_initializeRRule","minTime","leftBorder","_getLeftBorder","between","forEach","date","endAppointmentTime","correctDate","createDateFromUTCWithLocalOffset","generateDates","_parseRecurrenceRule","validateRRule","byday","split","currentOffset","_getTimeZoneOffset","offsetDate","Date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","object","field","getAsciiStringByDate","substring","toUpperCase","match","exceptionText","_parseExceptionToRawArray","_this$_createDateTupl","_createDateTuple","_this$_createDateTupl2","year","month","hours","minutes","seconds","isUtc","UTC","getTimezoneOffset","_this","ruleOptions","RRule","parseString","firstDayOfWeek","dtstart","wkst","weekDayNumbers","_createRRule","exception","exceptionStrings","exceptionDates","map","getDateByAsciiString","getPostProcessedException","utcDate","exdate","_dispose","RRuleSet","rrule","appointmentDuration","isSameAppointmentDates","ruleObject","ruleParts","ruleName","toLowerCase","ruleValue","count","parseInt","isNaN","interval","until","parseResult","shift","splice","unshift","_brokenRuleNameExists","inArray","_wrongCountRule","_wrongIntervalRule","_wrongDayOfWeek","_wrongByMonthDayRule","_wrongByMonth","_wrongUntilRule","_logBrokenRule","wrongUntil","wrongCount","wrongByMonthDay","byMonthDay","bymonthday","wrongByMonth","byMonth","bymonth","wrongInterval","byDay","daysByRule","daysFromByDayRule","brokenDaysExist","each","_","day","hasOwnProperty","brokenRuleExists","log"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (ui/scheduler/recurrence.js)\r\n * Version: 20.2.5\r\n * Build date: Fri Jan 15 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nexports.getRecurrenceProcessor = getRecurrenceProcessor;\r\nvar _errors = _interopRequireDefault(require(\"../../core/errors\"));\r\nvar _iterator = require(\"../../core/utils/iterator\");\r\nvar _array = require(\"../../core/utils/array\");\r\nvar _rrule = require(\"rrule\");\r\nvar _date = _interopRequireDefault(require(\"../../core/utils/date\"));\r\nvar _utilsTimeZone = _interopRequireDefault(require(\"./utils.timeZone.js\"));\r\n\r\nfunction _interopRequireDefault(obj) {\r\n    return obj && obj.__esModule ? obj : {\r\n        \"default\": obj\r\n    }\r\n}\r\n\r\nfunction _slicedToArray(arr, i) {\r\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest()\r\n}\r\n\r\nfunction _nonIterableRest() {\r\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")\r\n}\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) {\r\n    if (!o) {\r\n        return\r\n    }\r\n    if (\"string\" === typeof o) {\r\n        return _arrayLikeToArray(o, minLen)\r\n    }\r\n    var n = Object.prototype.toString.call(o).slice(8, -1);\r\n    if (\"Object\" === n && o.constructor) {\r\n        n = o.constructor.name\r\n    }\r\n    if (\"Map\" === n || \"Set\" === n) {\r\n        return Array.from(o)\r\n    }\r\n    if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {\r\n        return _arrayLikeToArray(o, minLen)\r\n    }\r\n}\r\n\r\nfunction _arrayLikeToArray(arr, len) {\r\n    if (null == len || len > arr.length) {\r\n        len = arr.length\r\n    }\r\n    for (var i = 0, arr2 = new Array(len); i < len; i++) {\r\n        arr2[i] = arr[i]\r\n    }\r\n    return arr2\r\n}\r\n\r\nfunction _iterableToArrayLimit(arr, i) {\r\n    if (\"undefined\" === typeof Symbol || !(Symbol.iterator in Object(arr))) {\r\n        return\r\n    }\r\n    var _arr = [];\r\n    var _n = true;\r\n    var _d = false;\r\n    var _e = void 0;\r\n    try {\r\n        for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {\r\n            _arr.push(_s.value);\r\n            if (i && _arr.length === i) {\r\n                break\r\n            }\r\n        }\r\n    } catch (err) {\r\n        _d = true;\r\n        _e = err\r\n    } finally {\r\n        try {\r\n            if (!_n && null != _i.return) {\r\n                _i.return()\r\n            }\r\n        } finally {\r\n            if (_d) {\r\n                throw _e\r\n            }\r\n        }\r\n    }\r\n    return _arr\r\n}\r\n\r\nfunction _arrayWithHoles(arr) {\r\n    if (Array.isArray(arr)) {\r\n        return arr\r\n    }\r\n}\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n    if (!(instance instanceof Constructor)) {\r\n        throw new TypeError(\"Cannot call a class as a function\")\r\n    }\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n    for (var i = 0; i < props.length; i++) {\r\n        var descriptor = props[i];\r\n        descriptor.enumerable = descriptor.enumerable || false;\r\n        descriptor.configurable = true;\r\n        if (\"value\" in descriptor) {\r\n            descriptor.writable = true\r\n        }\r\n        Object.defineProperty(target, descriptor.key, descriptor)\r\n    }\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n    if (protoProps) {\r\n        _defineProperties(Constructor.prototype, protoProps)\r\n    }\r\n    if (staticProps) {\r\n        _defineProperties(Constructor, staticProps)\r\n    }\r\n    return Constructor\r\n}\r\nvar toMs = _date.default.dateToMilliseconds;\r\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"];\r\nvar freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"];\r\nvar days = {\r\n    SU: 0,\r\n    MO: 1,\r\n    TU: 2,\r\n    WE: 3,\r\n    TH: 4,\r\n    FR: 5,\r\n    SA: 6\r\n};\r\nvar loggedWarnings = [];\r\nvar recurrence = null;\r\n\r\nfunction getRecurrenceProcessor() {\r\n    if (!recurrence) {\r\n        recurrence = new RecurrenceProcessor\r\n    }\r\n    return recurrence\r\n}\r\nvar RecurrenceProcessor = function() {\r\n    function RecurrenceProcessor() {\r\n        _classCallCheck(this, RecurrenceProcessor);\r\n        this.rRule = null;\r\n        this.rRuleSet = null;\r\n        this.validator = new RecurrenceValidator\r\n    }\r\n    _createClass(RecurrenceProcessor, [{\r\n        key: \"generateDates\",\r\n        value: function(options) {\r\n            var result = [];\r\n            var recurrenceRule = this.evalRecurrenceRule(options.rule);\r\n            var rule = recurrenceRule.rule;\r\n            if (!recurrenceRule.isValid || !rule.freq) {\r\n                return result\r\n            }\r\n            var startDateUtc = _utilsTimeZone.default.createUTCDateWithLocalOffset(options.start);\r\n            var endDateUtc = _utilsTimeZone.default.createUTCDateWithLocalOffset(options.end);\r\n            var minDateUtc = _utilsTimeZone.default.createUTCDateWithLocalOffset(options.min);\r\n            var maxDateUtc = _utilsTimeZone.default.createUTCDateWithLocalOffset(options.max);\r\n            var duration = endDateUtc ? endDateUtc.getTime() - startDateUtc.getTime() : 0;\r\n            this._initializeRRule(options, startDateUtc);\r\n            var minTime = minDateUtc.getTime();\r\n            var leftBorder = this._getLeftBorder(options, minDateUtc, duration);\r\n            this.rRuleSet.between(leftBorder, maxDateUtc, true).forEach(function(date) {\r\n                var endAppointmentTime = date.getTime() + duration;\r\n                if (endAppointmentTime >= minTime) {\r\n                    var correctDate = _utilsTimeZone.default.createDateFromUTCWithLocalOffset(date);\r\n                    result.push(correctDate)\r\n                }\r\n            });\r\n            return result\r\n        }\r\n    }, {\r\n        key: \"hasRecurrence\",\r\n        value: function(options) {\r\n            return !!this.generateDates(options).length\r\n        }\r\n    }, {\r\n        key: \"evalRecurrenceRule\",\r\n        value: function(rule) {\r\n            var result = {\r\n                rule: {},\r\n                isValid: false\r\n            };\r\n            if (rule) {\r\n                result.rule = this._parseRecurrenceRule(rule);\r\n                result.isValid = this.validator.validateRRule(result.rule, rule)\r\n            }\r\n            return result\r\n        }\r\n    }, {\r\n        key: \"isValidRecurrenceRule\",\r\n        value: function(rule) {\r\n            return this.evalRecurrenceRule(rule).isValid\r\n        }\r\n    }, {\r\n        key: \"daysFromByDayRule\",\r\n        value: function(rule) {\r\n            var result = [];\r\n            if (rule.byday) {\r\n                if (Array.isArray(rule.byday)) {\r\n                    result = rule.byday\r\n                } else {\r\n                    result = rule.byday.split(\",\")\r\n                }\r\n            }\r\n            return result\r\n        }\r\n    }, {\r\n        key: \"getAsciiStringByDate\",\r\n        value: function(date) {\r\n            var currentOffset = this._getTimeZoneOffset() * toMs(\"minute\");\r\n            var offsetDate = new Date(date.getTime() + currentOffset);\r\n            return offsetDate.getFullYear() + (\"0\" + (offsetDate.getMonth() + 1)).slice(-2) + (\"0\" + offsetDate.getDate()).slice(-2) + \"T\" + (\"0\" + offsetDate.getHours()).slice(-2) + (\"0\" + offsetDate.getMinutes()).slice(-2) + (\"0\" + offsetDate.getSeconds()).slice(-2) + \"Z\"\r\n        }\r\n    }, {\r\n        key: \"getRecurrenceString\",\r\n        value: function(object) {\r\n            if (!object || !object.freq) {\r\n                return\r\n            }\r\n            var result = \"\";\r\n            for (var field in object) {\r\n                var value = object[field];\r\n                if (\"interval\" === field && value < 2) {\r\n                    continue\r\n                }\r\n                if (\"until\" === field) {\r\n                    value = this.getAsciiStringByDate(value)\r\n                }\r\n                result += field + \"=\" + value + \";\"\r\n            }\r\n            result = result.substring(0, result.length - 1);\r\n            return result.toUpperCase()\r\n        }\r\n    }, {\r\n        key: \"_parseExceptionToRawArray\",\r\n        value: function(value) {\r\n            return value.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/)\r\n        }\r\n    }, {\r\n        key: \"getDateByAsciiString\",\r\n        value: function(exceptionText) {\r\n            if (\"string\" !== typeof exceptionText) {\r\n                return exceptionText\r\n            }\r\n            var result = this._parseExceptionToRawArray(exceptionText);\r\n            if (!result) {\r\n                return null\r\n            }\r\n            var _this$_createDateTupl = this._createDateTuple(result),\r\n                _this$_createDateTupl2 = _slicedToArray(_this$_createDateTupl, 7),\r\n                year = _this$_createDateTupl2[0],\r\n                month = _this$_createDateTupl2[1],\r\n                date = _this$_createDateTupl2[2],\r\n                hours = _this$_createDateTupl2[3],\r\n                minutes = _this$_createDateTupl2[4],\r\n                seconds = _this$_createDateTupl2[5],\r\n                isUtc = _this$_createDateTupl2[6];\r\n            if (isUtc) {\r\n                return new Date(Date.UTC(year, month, date, hours, minutes, seconds))\r\n            }\r\n            return new Date(year, month, date, hours, minutes, seconds)\r\n        }\r\n    }, {\r\n        key: \"_dispose\",\r\n        value: function() {\r\n            if (this.rRuleSet) {\r\n                delete this.rRuleSet;\r\n                this.rRuleSet = null\r\n            }\r\n            if (this.rRule) {\r\n                delete this.rRule;\r\n                this.rRule = null\r\n            }\r\n        }\r\n    }, {\r\n        key: \"_getTimeZoneOffset\",\r\n        value: function() {\r\n            return (new Date).getTimezoneOffset()\r\n        }\r\n    }, {\r\n        key: \"_initializeRRule\",\r\n        value: function(options, startDateUtc) {\r\n            var _this = this;\r\n            var ruleOptions = _rrule.RRule.parseString(options.rule);\r\n            var firstDayOfWeek = options.firstDayOfWeek;\r\n            ruleOptions.dtstart = startDateUtc;\r\n            if (!ruleOptions.wkst && firstDayOfWeek) {\r\n                var weekDayNumbers = [6, 0, 1, 2, 3, 4, 5];\r\n                ruleOptions.wkst = weekDayNumbers[firstDayOfWeek]\r\n            }\r\n            this._createRRule(ruleOptions);\r\n            if (options.exception) {\r\n                var exceptionStrings = options.exception;\r\n                var exceptionDates = exceptionStrings.split(\",\").map(function(rule) {\r\n                    return _this.getDateByAsciiString(rule)\r\n                });\r\n                exceptionDates.forEach(function(date) {\r\n                    if (options.getPostProcessedException) {\r\n                        date = options.getPostProcessedException(date)\r\n                    }\r\n                    var utcDate = _utilsTimeZone.default.createUTCDateWithLocalOffset(date);\r\n                    _this.rRuleSet.exdate(utcDate)\r\n                })\r\n            }\r\n        }\r\n    }, {\r\n        key: \"_createRRule\",\r\n        value: function(ruleOptions) {\r\n            this._dispose();\r\n            var rRuleSet = new _rrule.RRuleSet;\r\n            this.rRuleSet = rRuleSet;\r\n            this.rRule = new _rrule.RRule(ruleOptions);\r\n            this.rRuleSet.rrule(this.rRule)\r\n        }\r\n    }, {\r\n        key: \"_getLeftBorder\",\r\n        value: function(options, minDateUtc, appointmentDuration) {\r\n            if (options.end && !_utilsTimeZone.default.isSameAppointmentDates(options.start, options.end)) {\r\n                return new Date(minDateUtc.getTime() - appointmentDuration)\r\n            }\r\n            return minDateUtc\r\n        }\r\n    }, {\r\n        key: \"_parseRecurrenceRule\",\r\n        value: function(recurrence) {\r\n            var ruleObject = {};\r\n            var ruleParts = recurrence.split(\";\");\r\n            for (var i = 0, len = ruleParts.length; i < len; i++) {\r\n                var rule = ruleParts[i].split(\"=\");\r\n                var ruleName = rule[0].toLowerCase();\r\n                var ruleValue = rule[1];\r\n                ruleObject[ruleName] = ruleValue\r\n            }\r\n            var count = parseInt(ruleObject.count);\r\n            if (!isNaN(count)) {\r\n                ruleObject.count = count\r\n            }\r\n            if (ruleObject.interval) {\r\n                var interval = parseInt(ruleObject.interval);\r\n                if (!isNaN(interval)) {\r\n                    ruleObject.interval = interval\r\n                }\r\n            } else {\r\n                ruleObject.interval = 1\r\n            }\r\n            if (ruleObject.freq && ruleObject.until) {\r\n                ruleObject.until = this.getDateByAsciiString(ruleObject.until)\r\n            }\r\n            return ruleObject\r\n        }\r\n    }, {\r\n        key: \"_createDateTuple\",\r\n        value: function(parseResult) {\r\n            var isUtc = void 0 !== parseResult[8];\r\n            parseResult.shift();\r\n            if (void 0 === parseResult[3]) {\r\n                parseResult.splice(3)\r\n            } else {\r\n                parseResult.splice(3, 1);\r\n                parseResult.splice(6)\r\n            }\r\n            parseResult[1]--;\r\n            parseResult.unshift(null);\r\n            return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc]\r\n        }\r\n    }]);\r\n    return RecurrenceProcessor\r\n}();\r\nvar RecurrenceValidator = function() {\r\n    function RecurrenceValidator() {\r\n        _classCallCheck(this, RecurrenceValidator)\r\n    }\r\n    _createClass(RecurrenceValidator, [{\r\n        key: \"validateRRule\",\r\n        value: function(rule, recurrence) {\r\n            if (this._brokenRuleNameExists(rule) || (0, _array.inArray)(rule.freq, freqNames) === -1 || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {\r\n                this._logBrokenRule(recurrence);\r\n                return false\r\n            }\r\n            return true\r\n        }\r\n    }, {\r\n        key: \"_wrongUntilRule\",\r\n        value: function(rule) {\r\n            var wrongUntil = false;\r\n            var until = rule.until;\r\n            if (void 0 !== until && !(until instanceof Date)) {\r\n                wrongUntil = true\r\n            }\r\n            return wrongUntil\r\n        }\r\n    }, {\r\n        key: \"_wrongCountRule\",\r\n        value: function(rule) {\r\n            var wrongCount = false;\r\n            var count = rule.count;\r\n            if (count && \"string\" === typeof count) {\r\n                wrongCount = true\r\n            }\r\n            return wrongCount\r\n        }\r\n    }, {\r\n        key: \"_wrongByMonthDayRule\",\r\n        value: function(rule) {\r\n            var wrongByMonthDay = false;\r\n            var byMonthDay = rule.bymonthday;\r\n            if (byMonthDay && isNaN(parseInt(byMonthDay))) {\r\n                wrongByMonthDay = true\r\n            }\r\n            return wrongByMonthDay\r\n        }\r\n    }, {\r\n        key: \"_wrongByMonth\",\r\n        value: function(rule) {\r\n            var wrongByMonth = false;\r\n            var byMonth = rule.bymonth;\r\n            if (byMonth && isNaN(parseInt(byMonth))) {\r\n                wrongByMonth = true\r\n            }\r\n            return wrongByMonth\r\n        }\r\n    }, {\r\n        key: \"_wrongIntervalRule\",\r\n        value: function(rule) {\r\n            var wrongInterval = false;\r\n            var interval = rule.interval;\r\n            if (interval && \"string\" === typeof interval) {\r\n                wrongInterval = true\r\n            }\r\n            return wrongInterval\r\n        }\r\n    }, {\r\n        key: \"_wrongDayOfWeek\",\r\n        value: function(rule) {\r\n            var byDay = rule.byday;\r\n            var daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);\r\n            var brokenDaysExist = false;\r\n            if (\"\" === byDay) {\r\n                brokenDaysExist = true\r\n            }(0, _iterator.each)(daysByRule, function(_, day) {\r\n                if (!Object.prototype.hasOwnProperty.call(days, day)) {\r\n                    brokenDaysExist = true;\r\n                    return false\r\n                }\r\n            });\r\n            return brokenDaysExist\r\n        }\r\n    }, {\r\n        key: \"_brokenRuleNameExists\",\r\n        value: function(rule) {\r\n            var brokenRuleExists = false;\r\n            (0, _iterator.each)(rule, function(ruleName) {\r\n                if ((0, _array.inArray)(ruleName, ruleNames) === -1) {\r\n                    brokenRuleExists = true;\r\n                    return false\r\n                }\r\n            });\r\n            return brokenRuleExists\r\n        }\r\n    }, {\r\n        key: \"_logBrokenRule\",\r\n        value: function(recurrence) {\r\n            if ((0, _array.inArray)(recurrence, loggedWarnings) === -1) {\r\n                _errors.default.log(\"W0006\", recurrence);\r\n                loggedWarnings.push(recurrence)\r\n            }\r\n        }\r\n    }]);\r\n    return RecurrenceValidator\r\n}();\r\n"]},"metadata":{},"sourceType":"script"}